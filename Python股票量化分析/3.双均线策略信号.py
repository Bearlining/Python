import pandas as pd
import pyecharts as pe

df = pd.read_excel('600177.xlsx', index_col='交易日期')
df = df.sort_values(['交易日期'], ascending=True)
'''
# 计算股票真实日涨跌幅
df['前收盘价'] = df['收盘价'].shift()
df['涨跌幅'] = df['收盘价'] / df['前收盘价'] - 1
# 计算涨跌停价格
df['涨停价'] = df['前收盘价'] * 1.1
df['跌停价'] = df['前收盘价'] * 0.9
# 计算股票资金曲线
df['资金曲线'] = (1 + df['涨跌幅']).cumprod()
df.loc[:, '资金曲线'] = df['资金曲线'] / df['资金曲线'].iat[1]
# 计算股票后复权价
df['收盘价_后复权'] = df['资金曲线'] * df['收盘价'].iat[1]
df['开盘价_后复权'] = df['开盘价'] / df['收盘价'] * df['收盘价_后复权']
df['最高价_后复权'] = df['最高价'] / df['收盘价'] * df['收盘价_后复权']
df['最低价_后复权'] = df['最低价'] / df['收盘价'] * df['收盘价_后复权']
# 由于第一行有缺失值，影响后续的计算处理，所以我们把第一行缺失值的删掉
df = df.dropna(how='any')  # 这是最开始找到的办法，现在我们直接用整理好的数据来做就可
'''
# 计算50日，200日均线
df['MA50'] = df['收盘价_后复权'].rolling(50).mean()
df['MA200'] = df['收盘价_后复权'].rolling(200).mean()

# 然后标记双均线上穿（50日线上穿200日线），买入信号
# 找到条件1（当天短周期均线价格>当天长周期均线价格）并且同时需要
# 找到条件2（当天前一天短周期均线价格<当天前一天长周期均线价格）
# 然后新增一列交易信号，把产生买入信号的对应行赋值为数字1
df.loc[(df['MA50'] > df['MA200']) &
       (df['MA50'].shift(1) < df['MA200'].shift(1)), '交易信号'] = 1

# 标记双均线下穿，卖出信号
# 找到条件1（当天短周期均线价格<当天长周期均线价格）并且同时需要
# 找到条件2（当天前一天短周期均线价格>当天前一天长周期均线价格）
# 然后新增一列交易信号，把产生买入信号的对应行赋值为数字0
df.loc[(df['MA50'] < df['MA200']) &
       (df['MA50'].shift(1) > df['MA200'].shift(1)), '交易信号'] = 0

# 将涨停无法买入的交易日交易信号设为空值
# 找到条件1（当天收盘价 > 当天涨停价格）并且同时需要
# 找到条件2（当天交易信号=1，即买入）
# 然后将交易信号中满足对应条件的行赋值为空值
df.loc[(df['收盘价'] >= df['涨停价']) &
       (df['交易信号'] == 1),
        '交易信号'] = None
# 将跌停无法卖出的交易日信号设为空值
# 找到条件1（当天收盘价 <= 当天涨停价格)并且同时需要
# 找到条件2（当天交易信号等于0，即卖出）
# 然后将交易信号中，同时满足对应条件的行赋值为空值
df.loc[(df['收盘价'] <= df['跌停价']) &
       (df['交易信号'] == 0),
        '交易信号'] = None

# 持仓信号标记
# 假设收盘时买入股票，则接下来一天才会开始持仓
df['持仓状态'] = df['交易信号'].fillna(method='ffill').shift().fillna(0)
'''
df['交易信号'].fillna(method='ffill') 函数会填充交易信号字段的空值，这里用到的参数 method='ffill' 代表向前填充。
假设交易信号只有4行 [NaN , 1 , NaN , NaN]，每一行空值都会按之前最近的一个非空值来填充自己，
ffill填充结果为 [NaN , 1 , 1 , 1]，首行找不到之前的非空数据就不会被填充
pandas里的方法是可以连续调用的，在填充空值后，连续调用 .shift() 移位，沿用上面例子的假设，[NaN , 1 , 1 , 1] 将
变为 [NaN , NaN , 1 , 1]，最后调用 .fillna(0) 将剩余空值填充为 0 [0 , 0 , 1 , 1]
'''
